/**
 * 
 */
package vitis.newscast;

import peernet.config.Configuration;
import peernet.core.CommonState;
import peernet.core.Node;
import peernet.core.Protocol;
import peernet.transport.Address;

/**
 * @author anca
 *
 */
public class Newscast extends Protocol
{
  private static final String PAR_CACHE = "cache";

  private static Node[] tn;
  private static int[] ts;
  private Node[] cache;
  private int[] tstamps;
  /**
   * @param prefix
   */
  public Newscast(String prefix)
  {
    super(prefix);
    final int cachesize = Configuration.getInt(prefix + "." + PAR_CACHE);
    if (Newscast.tn == null || Newscast.tn.length < cachesize) {
      Newscast.tn = new Node[cachesize];
      Newscast.ts = new int[cachesize];
    }
  
    cache = new Node[cachesize];
    tstamps = new int[cachesize];
  }



  /* (non-Javadoc)
   * @see peernet.core.Protocol#processEvent(peernet.transport.Address, peernet.core.Node, int, java.lang.Object)
   */
  @Override
  public void processEvent(Address src, Node node, int pid, Object event)
  {
    // TODO Auto-generated method stub
  }



  /* (non-Javadoc)
   * @see peernet.core.Protocol#nextCycle(peernet.core.Node, int)
   */
  @Override
  public void nextCycle(Node node, int protocolID)
  {
    // TODO Auto-generated method stub
  }
  
  private Node getPeer() {

    final int d = degree();
    if (d == 0)
      return null;
    int index = CommonState.r.nextInt(d);
    Node result = cache[index];
  
    if (result.isUp())
      return result;
  
    // proceed towards older entries
    for (int i = index + 1; i < d; ++i)
      if (cache[i].isUp())
        return cache[i];
  
    // proceed towards younger entries
    for (int i = index - 1; i >= 0; --i)
      if (cache[i].isUp())
        return cache[i];
  
    // no accessible peer
    return null;
  }
  
//--------------------------------------------------------------------
  private void merge(Node thisNode, Newscast peer, Node peerNode) {
    int i1 = 0; /* Index first cache */
    int i2 = 0; /* Index second cache */
    boolean first;
    boolean lastTieWinner = CommonState.r.nextBoolean();
    int i = 1; // Index new cache. first element set in the end
    // SimpleNewscast.tn[0] is always null. it's never written anywhere
    final int d1 = degree();
    final int d2 = peer.degree();
    // cachesize is cache.length
  
    // merging two arrays
    while (i < cache.length && i1 < d1 && i2 < d2) {
      if (tstamps[i1] == peer.tstamps[i2]) {
        lastTieWinner = first = !lastTieWinner;
      } else {
        first = tstamps[i1] > peer.tstamps[i2];
      }
  
      if (first) {
        if (cache[i1] != peerNode && !Newscast.contains(i, cache[i1])) {
          Newscast.tn[i] = cache[i1];
          Newscast.ts[i] = tstamps[i1];
          i++;
        }
        i1++;
      } else {
        if (peer.cache[i2] != thisNode
            && !Newscast.contains(i, peer.cache[i2])) {
          Newscast.tn[i] = peer.cache[i2];
          Newscast.ts[i] = peer.tstamps[i2];
          i++;
        }
        i2++;
      }
    }
  
    // if one of the original arrays got fully copied into
    // tn and there is still place, fill the rest with the other
    // array
    if (i < cache.length) {
      // only one of the for cycles will be entered
  
      for (; i1 < d1 && i < cache.length; ++i1) {
        if (cache[i1] != peerNode && !Newscast.contains(i, cache[i1])) {
          Newscast.tn[i] = cache[i1];
          Newscast.ts[i] = tstamps[i1];
          i++;
        }
      }
  
      for (; i2 < d2 && i < cache.length; ++i2) {
        if (peer.cache[i2] != thisNode
            && !Newscast.contains(i, peer.cache[i2])) {
          Newscast.tn[i] = peer.cache[i2];
          Newscast.ts[i] = peer.tstamps[i2];
          i++;
        }
      }
    }
  
    // if the two arrays were not enough to fill the buffer
    // fill in the rest with nulls
    if (i < cache.length) {
      for (; i < cache.length; ++i) {
        Newscast.tn[i] = null;
      }
    }
  }

//--------------------------------------------------------------------
  private static boolean contains(int size, Node peer) {
    for (int i = 0; i < size; i++) {
      if (Newscast.tn[i] == peer)
        return true;
    }
    return false;
  }

//--------------------------------------------------------------------
  public Node getNeighbor(int i) {
    return cache[i];
  }

//--------------------------------------------------------------------
  public int degree() {
  
    int len = cache.length - 1;
    while (len >= 0 && cache[len] == null)
      len--;
    return len + 1;
  }

//--------------------------------------------------------------------
  public boolean addNeighbor(Node node) {
  
    int i;
    for (i = 0; i < cache.length && cache[i] != null; i++) {
      if (cache[i] == node)
        return false;
    }
  
    if (i < cache.length) {
      if (i > 0 && tstamps[i - 1] < (int)CommonState.getTime()) {
        // we need to insert to the first position
        for (int j = cache.length - 2; j >= 0; --j) {
          cache[j + 1] = cache[j];
          tstamps[j + 1] = tstamps[j];
        }
        i = 0;
      }
      cache[i] = node;
      tstamps[i] = CommonState.getIntTime();
      return true;
    } else
      throw new IndexOutOfBoundsException();
  }

//--------------------------------------------------------------------
  public boolean contains(Node n) {
    for (int i = 0; i < cache.length; i++) {
      if (cache[i] == n)
        return true;
    }
    return false;
  }

//--------------------------------------------------------------------
  public void onKill() {
    cache = null;
    tstamps = null;
  }
  
  public Object clone() {
    
    Newscast sn = null;
    sn = (Newscast) super.clone();
    sn.cache = new Node[cache.length];
    sn.tstamps = new int[tstamps.length];
    System.arraycopy(cache, 0, sn.cache, 0, cache.length);
    System.arraycopy(tstamps, 0, sn.tstamps, 0, tstamps.length);
    return sn;
  }
}
